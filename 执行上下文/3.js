
/*
  补充递归调用中的一点：递归调用需要一个终止的条件，否则，无限递归会导致内存溢出
  function foo() {
    arguments.callee()
  }

  foo()        // Uncaught RangeError: Maximum call stack size exceeded

  3、内存空间
  3-1、内存结构
  （1）、栈数据结构
  栈结构的特点是“后进先出”

  （2）、堆数据结构
  堆结构允许程序在运行时动态地申请某个大小的内存空间，它是一种无序的树状结构。JS不允许直接访问堆内存的位置

  （3）、队列
  队列的特点是“先进先出”

  3-2、变量存放
  （1）、基本类型（Undefined、Null、String、Boolean、Number、Symbol）
  保存在栈中。由于基本类型的值不能被更改，占据了固定大小的内存，按值访问

  （2）、引用类型
  保存在堆中。引用类型的值大小不固定，但是内存地址的大小是固定的， 因此，把引用类型的地址存放在栈中，把引用类型的值存放在堆中。
  读取引用类型变量时，先从栈中读取内存地址，然后再根据地址在堆中找到对应的值，这就是按引用访问

  在计算机的数据结构中，栈比堆的运算速度快。由于引用类型的动态属性，将其放在堆中是为了不影响栈的效率，所以查找引用类型值的时候先去栈中查找，再去堆中查找

  var a = 8;
  var b = a;
  b = 30;

  console.log(a);   // 8

  // 变量a，b都是基本类型的值，它们的值是存储在栈中的，a、b分别有各自独立的栈空间，所以修改了b的值以后，a的值并不会发生变化。


  var obj1 = {
    a: 3
  };
  var obj2 = obj1;
  obj2.a = 9;

  console.log(obj1.a);     // 9

  // obj1和obj2 是引用类型的值，栈内存中存放地址指向堆内存中的对象，引用类型的复制会为新的变量自动分配一个新的值保存在变量对象中，但只是引用类型的一个地址指针而已，实际指向的是同一个对象，所以修改obj2.a的值后，相应的obj1.a也就发生了改变


  var obj1 = {
    a: 3
  };
  var obj2 = obj1;
  obj1 = null;

  console.log(obj2.a);     // 3

  // null是基本类型的值，执行obj1 = null只是把obj1存储在栈内存中地址改变成了基本类型null，并不会影响堆内存中的对象，所以obj2.a的值不受影响

  3-3、垃圾收集
  JavaScript的内存生命周期是：
  （1）、分配内存
  （2）、使用分配的内存（读、写）
  （3）、不需要时释放内存

  JavaScript有自动垃圾收集的机制，最常用的是通过 标记清除 的算法来找到哪些对象是不再使用的，执行 obj = null 其实仅仅只是做了一个释放引用的操作，让obj失去对堆内存中对象的引用，脱离执行环境，没有被引用的值会在下一次垃圾收集器执行操作时被找到并释放

  在函数（局部）作用域中，当函数执行完毕，作用域内的局部变量也没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此，需要尽量避免使用全局变量
*/

  var a = {x: 1};
  var b = a;
  a.y = a = {z: 2};

  console.log(a.y);   // undefined 
  console.log(b.y);   // {z: 2}

  // 优先级。“.”的优先级高于“=”，所以先执行 a.y，堆内存中的 {x:1}就会变成 {x: 1， y: undefined}，改变之后相应的 b.y 也发生了变化，因为指向的是同一个对象
  // 赋值操作是 从右到左，所以先执行 a = {z: 2}，a的引用就被改变了，然后这个返回值 {z: 2} 又赋值给了 a.y，需要注意的是 a.y 已经率先执行过了，并且指向的是 {x: 1， y: undefined}，因此，该对象被赋值后就变成了 {x: 1， y: {z: 2}}，由于a的指向被改变了，该对象就只剩被b所引用 

  // https://segmentfault.com/a/1190000004224719

  
  
  

